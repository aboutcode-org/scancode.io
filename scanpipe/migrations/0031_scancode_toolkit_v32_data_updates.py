# Generated by Django 4.2 on 2023-05-05 10:11

from django.db import migrations
from django.db.models import Q


def compute_package_declared_license_expression_spdx(apps, schema_editor):
    """
    Compute DiscoveredPackage `declared_license_expression_spdx`, when missing,
    from `declared_license_expression`, when available.
    """
    from licensedcode.cache import build_spdx_license_expression

    DiscoveredPackage = apps.get_model("scanpipe", "DiscoveredPackage")
    packages = DiscoveredPackage.objects.filter(
        ~Q(declared_license_expression="") & Q(declared_license_expression_spdx="")
    )

    package_count = packages.count()
    print(f"Compute declared_license_expression_spdx for {package_count:,} packages.")

    chunk_size = 2000
    for index, package in enumerate(packages.iterator(chunk_size=chunk_size)):
        if not (index % chunk_size):
            print(f"  {index:,} / {package_count:,}")
        if spdx := build_spdx_license_expression(package.declared_license_expression):
            package.declared_license_expression_spdx = spdx
            package.save()


def compute_resource_detected_license_expression(apps, schema_editor):
    """
    Compute CodebaseResource `detected_license_expression` and
    `detected_license_expression_spdx` from old `license_expressions` field.
    """
    from license_expression import combine_expressions
    from licensedcode.cache import build_spdx_license_expression

    CodebaseResource = apps.get_model("scanpipe", "CodebaseResource")
    resources = CodebaseResource.objects.filter(~Q(license_expressions=[]))

    resource_count = resources.count()
    print(f"Compute detected_license_expression for {resource_count:,} resources.")

    chunk_size = 2000
    for index, resource in enumerate(resources.iterator(chunk_size=chunk_size)):
        if not (index % chunk_size):
            print(f"  {index:,} / {resource_count:,}")

        combined_expression = str(combine_expressions(resource.license_expressions))
        license_expression_spdx = build_spdx_license_expression(combined_expression)
        resource.declared_license_expression = combined_expression
        resource.declared_license_expression_spdx = license_expression_spdx
        resource.save()


def _convert_matches_to_detections(license_matches):
    """
    Return a list of scancode v32 LicenseDetection mappings from provided
    ``license_matches``: a list of the scancode v31 LicenseMatch mappings.
    """
    from license_expression import combine_expressions
    from licensedcode.detection import get_uuid_on_content
    from commoncode.text import python_safe_name

    match_attributes = ["score", "start_line", "end_line", "matched_text"]
    rule_attributes = [
        "matched_length",
        "match_coverage",
        "matcher",
        "rule_relevance",
    ]
    license_detection = {}
    detection_matches = []

    for match in license_matches:
        detection_match = {}

        for attribute in match_attributes:
            detection_match[attribute] = match[attribute]
        for attribute in rule_attributes:
            detection_match[attribute] = match["matched_rule"][attribute]

        detection_match["rule_identifier"] = match["matched_rule"]["identifier"]
        detection_match["license_expression"] = match["matched_rule"][
            "license_expression"
        ]
        detection_match["rule_url"] = None
        detection_matches.append(detection_match)

    license_expressions = [match["license_expression"] for match in detection_matches]
    hashable_details = tuple(
        [
            (match["score"], match["rule_identifier"], match["matched_text"])
            for match in detection_matches
        ]
    )
    uuid = get_uuid_on_content(hashable_details)

    license_detection["matches"] = detection_matches
    license_detection["license_expression"] = str(
        combine_expressions(license_expressions)
    )
    license_detection["identifier"] = "{}-{}".format(
        python_safe_name(license_detection["license_expression"]), uuid
    )

    return [license_detection]


def compute_resource_license_detections(apps, schema_editor):
    """Compute CodebaseResource `license_detections` from old `licenses` field."""
    CodebaseResource = apps.get_model("scanpipe", "CodebaseResource")
    resources = CodebaseResource.objects.filter(~Q(licenses=[])).only("licenses")

    resource_count = resources.count()
    print(f"Compute license_detections for {resource_count:,} resources.")

    chunk_size = 2000
    for index, resource in enumerate(resources.iterator(chunk_size=chunk_size)):
        if not (index % chunk_size):
            print(f"  {index:,} / {resource_count:,}")

        detections = _convert_matches_to_detections(resource.licenses)
        resource.license_detections = detections
        resource.save()


class Migration(migrations.Migration):
    dependencies = [
        ("scanpipe", "0030_scancode_toolkit_v32_model_updates"),
    ]

    operations = [
        migrations.RunPython(
            compute_package_declared_license_expression_spdx,
            reverse_code=migrations.RunPython.noop,
        ),
        migrations.RunPython(
            compute_resource_detected_license_expression,
            reverse_code=migrations.RunPython.noop,
        ),
        migrations.RunPython(
            compute_resource_license_detections,
            reverse_code=migrations.RunPython.noop,
        ),
    ]
