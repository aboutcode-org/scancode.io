# SPDX-License-Identifier: Apache-2.0
#
# http://nexb.com and https://github.com/aboutcode-org/scancode.io
# The ScanCode.io software is licensed under the Apache License version 2.0.
# Data generated with ScanCode.io is provided as-is without warranties.
# ScanCode is a trademark of nexB Inc.
#
# You may not use this software except in compliance with the License.
# You may obtain a copy of the License at: http://apache.org/licenses/LICENSE-2.0
# Unless required by applicable law or agreed to in writing, software distributed
# under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the License for the
# specific language governing permissions and limitations under the License.
#
# Data Generated with ScanCode.io is provided on an "AS IS" BASIS, WITHOUT WARRANTIES
# OR CONDITIONS OF ANY KIND, either express or implied. No content created from
# ScanCode.io should be considered or used as legal advice. Consult an Attorney
# for any legal advice.
#
# ScanCode.io is a free software code scanning tool from nexB Inc. and others.
# Visit https://github.com/aboutcode-org/scancode.io for support and download.

import json
from collections import defaultdict
from contextlib import suppress
from pathlib import Path

from django.core.validators import EMPTY_VALUES

from cyclonedx.model import license as cdx_license_model
from cyclonedx.model.bom import Bom
from cyclonedx.schema import SchemaVersion
from cyclonedx.schema.schema import BaseSchemaVersion
from cyclonedx.validation import ValidationError
from cyclonedx.validation.json import JsonStrictValidator
from defusedxml import ElementTree as SafeElementTree


def resolve_license(license):
    """Return license expression/id/name from license item."""
    if isinstance(license, cdx_license_model.LicenseExpression):
        return license.value
    elif isinstance(license, cdx_license_model.License):
        return license.id or license.name


def get_declared_licenses(licenses):
    """Return resolved license from list of LicenseChoice."""
    if not licenses:
        return ""

    resolved_licenses = [resolve_license(license) for license in licenses]
    return "\n".join(resolved_licenses)


def get_checksums(component):
    """Return dict of all the checksums from a component."""
    if not component.hashes:
        return {}

    algorithm_map_cdx_scio = {
        "MD5": "md5",
        "SHA-1": "sha1",
        "SHA-256": "sha256",
        "SHA-512": "sha512",
    }

    return {
        algorithm_map_cdx_scio[algo_hash.alg]: algo_hash.content
        for algo_hash in component.hashes
        if algo_hash.alg in algorithm_map_cdx_scio
    }


def get_external_references(component):
    """Return dict of reference urls from list of `component.external_references`."""
    external_references = component.external_references
    if not external_references:
        return {}

    references = defaultdict(list)
    for reference in external_references:
        reference_url = reference.url
        if reference_url and reference_url.uri:
            references[reference.type.value].append(reference_url.uri)

    return dict(references)


def get_properties_data(component):
    """Return the properties as dict, extracted from  `component.properties`."""
    prefix = "aboutcode:"
    properties_data = {}
    properties_dict = {
        component_property.name: component_property.value
        for component_property in component.properties
    }

    for property_name, property_value in properties_dict.items():
        if property_name.startswith(prefix) and property_value not in EMPTY_VALUES:
            package_field_name = property_name.replace(prefix, "", 1)
            properties_data[package_field_name] = property_value

    # Mapping of few other properties found in SBOM generated by external tools.
    property_mapping = {
        "ResolvedUrl": "download_url",  # generated by "CycloneDX/cdxgen"
    }

    for property_name, package_field_name in property_mapping.items():
        if properties_data.get(package_field_name) not in EMPTY_VALUES:
            continue  # Skip if a value is already set for that field

        property_value = properties_dict.get(property_name)
        if property_value not in EMPTY_VALUES:
            properties_data[package_field_name] = property_value

    return properties_data


def validate_document(document):
    """
    Check the validity of this CycloneDX document.

    The validator is loaded from the document specVersion property.
    """
    if isinstance(document, str):
        document_str = document
        document = json.loads(document)
    else:
        document_str = json.dumps(document)

    spec_version = document.get("specVersion")
    if not spec_version:
        return ValidationError("'specVersion' is a required property")

    schema_version = SchemaVersion.from_version(spec_version)

    json_validator = JsonStrictValidator(schema_version)
    json_validation_errors = json_validator.validate_str(document_str)
    return json_validation_errors


def is_cyclonedx_bom(input_location):
    """Return True if the file at `input_location` is a CycloneDX BOM."""
    if str(input_location).endswith(".json"):
        with suppress(Exception):
            data = json.loads(Path(input_location).read_text())
            if data.get("bomFormat") == "CycloneDX":
                return True

    elif str(input_location).endswith(".xml"):
        with suppress(Exception):
            et = SafeElementTree.parse(input_location)
            if "cyclonedx" in et.getroot().tag:
                return True

    return False


def cyclonedx_component_to_package_data(
    cdx_component, dependencies=None, vulnerabilities=None
):
    """Return package_data from CycloneDX component."""
    dependencies = dependencies or {}
    vulnerabilities = vulnerabilities or {}
    extra_data = {}

    bom_ref = str(cdx_component.bom_ref)
    if depends_on := dependencies.get(bom_ref):
        extra_data["depends_on"] = depends_on

    package_url_dict = {}
    if cdx_component.purl:
        package_url_dict = cdx_component.purl.to_dict(encode=True)

    declared_license = get_declared_licenses(licenses=cdx_component.licenses)

    if external_references := get_external_references(cdx_component):
        extra_data["externalReferences"] = external_references

    if nested_components := cdx_component.get_all_nested_components(include_self=False):
        nested_purls = [component.bom_ref.value for component in nested_components]
        extra_data["nestedComponents"] = sorted(nested_purls)

    affected_by_vulnerabilities = []
    if affected_by := vulnerabilities.get(bom_ref):
        for cdx_vulnerability in affected_by:
            cdx_vulnerability_json = cdx_vulnerability.as_json(view_=BaseSchemaVersion)
            affected_by_vulnerabilities.append(
                {
                    "vulnerability_id": str(cdx_vulnerability.id),
                    "summary": cdx_vulnerability.description,
                    "cdx_vulnerability_data": json.loads(cdx_vulnerability_json),
                }
            )

    package_data = {
        # Store the original "bom_ref" as package_uid for dependencies resolution.
        "package_uid": bom_ref,
        "name": cdx_component.name,
        "extracted_license_statement": declared_license,
        "copyright": cdx_component.copyright,
        "version": cdx_component.version,
        "description": cdx_component.description,
        "extra_data": extra_data,
        "affected_by_vulnerabilities": affected_by_vulnerabilities,
        **package_url_dict,
        **get_checksums(cdx_component),
        **get_properties_data(cdx_component),
    }

    return {
        key: value for key, value in package_data.items() if value not in EMPTY_VALUES
    }


def get_components(bom):
    """Return components from CycloneDX BOM except for the metadata.component."""
    for component in bom.components:
        yield from component.get_all_nested_components(include_self=True)


def delete_ignored_root_properties(cyclonedx_document_json):
    """
    Remove root properties from the CycloneDX document that are irrelevant
    when loading SBOM component data as packages.

    This function aims to maximize compatibility by excluding unsupported SPEC
    definitions while utilizing the cyclonedx-python-lib library.

    The data contained in these properties is unnecessary for loading components
    from the SBOM and can be safely disregarded.

    https://github.com/CycloneDX/cyclonedx-python-lib/issues/578
    """
    ignored_root_properties = [
        "metadata",
        "services",
        "externalReferences",
        "compositions",
        "annotations",
        "formulation",
        "declarations",
        "definitions",
        "properties",
    ]

    cleaned_document = {
        key: value
        for key, value in cyclonedx_document_json.items()
        if key not in ignored_root_properties
    }

    return cleaned_document


def cleanup_components_properties(cyclonedx_document_json):
    """
    Remove entries for which no values are set, such as ``{"name": ""}`` or
    ``"licenses":[{}]``.

    Also remove the properties that are not used in the context of loading packages
    from SBOM and that  may be unsupported by the cyclonedx-python-lib library.

    Class like cyclonedx.model.contact.OrganizationalEntity raise a
    NoPropertiesProvidedException while it is not enforced in the spec.

    See https://github.com/CycloneDX/cyclonedx-python-lib/issues/600
    """
    entries_to_delete = []
    ignored_properties = [
        "evidence",
        "omniborId",
        "swhid",
        "swid",
        "modified",
        "pedigree",
        "releaseNotes",
        "modelCard",
        "data",
        "cryptoProperties",
        "signature",
    ]

    def is_empty(value):
        if isinstance(value, dict) and not any(value.values()):
            return True
        elif isinstance(value, list) and not any(value):
            return True

    for component in cyclonedx_document_json.get("components", []):
        for property_name, property_value in component.items():
            if is_empty(property_value) or property_name in ignored_properties:
                entries_to_delete.append((component, property_name))

    # Delete the keys outside the main check loop
    for component, property_name in entries_to_delete:
        del component[property_name]

    return cyclonedx_document_json


def get_bom_instance_from_file(input_location):
    """Return a Bom instance from the `input_location` CycloneDX document file."""
    input_path = Path(input_location)
    document_data = input_path.read_text()

    if str(input_location).endswith(".xml"):
        cyclonedx_document = SafeElementTree.fromstring(document_data)
        cyclonedx_bom = Bom.from_xml(cyclonedx_document)
        return cyclonedx_bom

    elif str(input_location).endswith(".json"):
        cyclonedx_document = json.loads(document_data)

        # Apply a few fixes pre-validation for maximum compatibility
        cyclonedx_document = delete_ignored_root_properties(cyclonedx_document)
        cyclonedx_document = cleanup_components_properties(cyclonedx_document)

        # Instead of validating and raising an error (which halts the entire loading
        # process), we proceed to load as much data as possible.
        # This approach prioritizes displaying data in the UI over the output of
        # validate_document() which is not quite pertinent in its current state.
        # Additionally, the ValidationError from validate_document() might include the
        # entire document content, which is impractical for large files.
        #
        # validation_error = validate_document(cyclonedx_document)

        cyclonedx_bom = Bom.from_json(data=cyclonedx_document)
        return cyclonedx_bom


def resolve_cyclonedx_packages(input_location):
    """Resolve the packages from the `input_location` CycloneDX document file."""
    cyclonedx_bom = get_bom_instance_from_file(input_location)
    if not cyclonedx_bom:
        return []

    components = get_components(cyclonedx_bom)

    # Store the ``bom_ref`` and the ``depends_on`` values on the extra_data field for
    # the dependency resolution that take place after the package creation.
    dependencies = defaultdict(list)
    for entry in cyclonedx_bom.dependencies:
        if depends_on := [str(dep.ref) for dep in entry.dependencies]:
            dependencies[str(entry.ref)].extend(depends_on)

    vulnerabilities = defaultdict(list)
    for vulnerability in cyclonedx_bom.vulnerabilities:
        for affected_target in vulnerability.affects:
            vulnerabilities[str(affected_target.ref)].append(vulnerability)

    return [
        cyclonedx_component_to_package_data(component, dependencies, vulnerabilities)
        for component in components
    ]
